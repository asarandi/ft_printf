/*--------------------------------------------*/
your function must be called ft_printf
your project must be written according to the norm
you have to handle errors carefully. in no way can your program quit in an unexpected manner (segmentation fault, bus error, double free, etc)
you must submit a makefile which will compile a libftprintf.a this lib will be linked to our testing main to give you your results
you'll have to submit a file called author containing your username followed by a '\n' at the root of your repository
you are allowed to use the following function:
	* write
	* malloc
	* free
	* exit
	* the functions of man 3 stdarg

/*--------------------------------------------*/
you have to recode libc's printf function
your function will be called ft_printf and will be prototyped similarly to printf
you won't do the buffer management in the printf function
you have to manage the following conversions sSpdDioOuUxXcC
you must manage %%
you must manage the flags #0-+ and space
you must manage the minimum field-width
you must manage the precision
you must manage the flags hh, h, l, ll, j, z

man 3 printf / man 3 stdarg

/*--------------------------------------------*/
more detailed conversions management eE, fF, gG, aA, n
more detailed flags management: *, $, L, '
non-existing flags management: %b to print in binary, %r to print a string of non-printable characters, %k to print a date in any ordinary ISO format, etc
management of alter tools for colors, fd, or other fun stuff like that
printf("Le fichier{cyan}%s{eoc} contient : {red}%s{eoc}", filename, str)

//
//    s S p d D i o O u U x X c C
//
//    %s = char *             - null terminated string
//    %S = wchar_t *          - wide char string ?
//    %p = void *             - printed in hexadecimal, %#x, %#lx
//    %d = int	              - signed decimal (32 bit)
//    %D = long int           - signed decimal (64 bit)
//    %i = int                - signed decimal (32 bit) same like %d
//    %o = unsigned int       - unsigned octal (32 bit)
//    %O = unsigned long int  - unsigned octal (64 bit)
//    %u = unsigned int       - unsigned decimal (32 bit)
//    %U = unsigned long int  - unsigned decimal (64 bit)
//    %x = unsigned int       - unsigned hexadecimal, lowercase
//    %X = unsigned int       - unsigned hexadecimal, uppercase
//    %c = int                - int converted to unsigned char
//    %C = wchar_t            - c with l (ell) modifier
//
//
//     %[parameter][flags][width][.precision][length]type
//
//
/////////////////////////////////////////////////////////////////////

You must manage the flags hh, h, l, ll, j, z

lengths:

	hh	int;  --> output char, 8 bit
	h	int;  --> output short, 16 bit
	l	long; --> output long, 64 bits
	ll	long long; --> 64 bits
	z	size_t;	--> 64 bits, signed/unsigned
	j	intmax_t; --> 64 bits, signed/unsigned
	t	ptrdiff_t; --> 64 bits, unsigned

/////////////////////////////////////////////////////////////////////

flags:
# For o conversions, the precision of the number is increased to
  force the first character of the output string to a zero.
  For x and X conversions, a non-zero result has 
  the string `0x' (or `0X' for X conversions) prepended to it.

0 Zero padding. For all conversions except n, the converted value is
  padded on the left with zeros rather than blanks. If a precision is
  given with a numeric conversion (d, i, o, u, i, x, and X),
  the 0 flag is ignored.

- the converted value is to be left adjusted on the field boundary.
  Except for n conversions, the converted value is padded on the right
  with blanks, rather than  on the left with blanks or zeros.
  A - overrides a 0 if both are given.

` ' (space) A blank should be left before a positive number produced
     by a signed conversion (a, A, d, e, E, f, F, g, G, or i).

+ A sign must always be placed before a number produced by a 
  signed conversion.  A + overrides a space if both are used.

/////////////////////////////////////////////////////////////////////











